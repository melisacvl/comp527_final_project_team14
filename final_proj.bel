%% COMP 527 Final Project
%% Beluga mechanization for Gödel's system T 
%% Team 14: Tortoise and the Achilles

%% The goal of this tutorial is to study the extension of ordinary logic with natural numbers and recursion over natural numbers.

%%%%%%%%%%%%%%%%
%% Objectives %%
%%%%%%%%%%%%%%%%

%% Inherit natural deduction calculus including existence and universal qualifiers
%% Implement the natural numbers (with zero and a successor)
%% Implement primitive recursion in the same way Gödel did  
%% Implement basic arithmetic operations using primitive recursion 

%% IF WE HAVE TIME: weak normalization proof???

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Defining Gödel's System T %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% Defining types and terms in Gödel's System T
i : type. 

LF tp : type =
  | nat : tp        % natural number type

  | ⊃ : tp → tp → tp
  | ⊤ : tp
  | ∧   : tp → tp → tp
  | ∨   : tp → tp → tp
  | ¬  : tp → tp
  | ∀  : (i → tp) → tp    
  | ∃  : (i → tp) → tp     
;

--prefix ¬ 10.
--infix ∧ 6 right.
--infix ∨ 5 right.
--infix ⊃ 4 right.
--prefix ∀ 8.
--prefix ∃ 8.

LF tm : tp → type =

  % natural numbers as a recursive type (with zero and a successor)
  | natIl : tm nat        % zero                                  
  | natIr : tm nat → tm nat  % succ    

  % primitive recursion     
  | natE : tm nat → tm A → (tm nat → tm A → tm A) → tm A

  % natural deduction calculus including existence and universal qualifiers
  | ⊃I : (tm A → tm B) → tm (A ⊃ B)
  | ⊃E : tm (A ⊃ B) → tm A → tm B      
  | ¬I : ({p:tp} tm A → tm p) → tm (¬ A)    
  | ¬E : tm (¬ A) → tm A → tm C      
  | ∧I : tm A → tm B → tm  (A ∧ B)    
  | ∧El : tm (A ∧ B) → tm A
  | ∧Er : tm (A ∧ B) → tm B
  | ∨Il : tm A → tm (A ∨ B)
  | ∨Ir : tm B → tm (A ∨ B)
  | ∨E  : tm (A ∨ B) → (tm A → tm C) → (tm B → tm C) → tm C
  | ⊤I : tm ⊤
  | ∀I : ({a:i} tm (A a)) → tm (∀ (\x. A x))     
  | ∀E : {T:i} tm (∀ A) → tm (A T) 
  | ∃I : {T:i} tm (A T) → tm (∃ A)     
  | ∃E : tm (∃ \x. A x) → ({a:i} tm (A a) → tm C) → tm C
;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Verification of Natural Deduction %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% The following proofs are to verify that we have correctly inherited natural deducition calculus, 
% including existence and universal qualifiers.

rec nd_a : [ ⊢ tm (((A ⊃ B) ∧ (A ∨ C)) ⊃ (B ∨ C)) ] = [ ⊢ ⊃I \u. (∨E (∧Er u) (\a. (∨Il (⊃E (∧El u) a))) (\c. (∨Ir c)))];
rec nd_b : [ ⊢ tm (∀ \x. (∃ \y.  P[x] ⊃ P[y]))] =[ ⊢ ∀I \a. ∃I a (⊃I \u. u)];

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Basic Arithmetic Operations %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%% Predecesor %%%%
%{ The definition of predecesor is as follows:

pred = λ(n : nat). rec(n; z; x.y. x)

where:
- n is the number we recurse over
- rec(n; z; x.y. x) is the recursive definition which states:
  - If n = 0, return 0
  - If n = successor of some number x and y = result of recursive call on x, then return x

This means:
pred(0) = 0         % since negative numbers do not exist in System T
pred(succ(k)) = k

Therefore, in our following proof:

We have a term of the following type: (nat ⊃ nat). 
This is because we want to the predecesor of natural number n, which is also of type natural number.

In our proof, n is our natural number input, x is the predecesor of n and r is the result of the recursion on x.
We output x, which we had already established is the predecesor of n.

}%

rec pred : [ ⊢ tm (nat ⊃ nat)] = [ ⊢ ⊃I \n. natE n natIl (\x. \r. x)];

%%%% Addition %%%%
%{ The definition of addition is as follows: 

add = λ(m : nat). λ(n : nat). rec(m; n; x.y. s(y))

where:
- m is the number we recurse over
- n is the number we add to
- the recursive definition rec(m; n; x.y. s(y)), which states:
  - If m = 0, return n
  - If m = successor of some nat x, let y = result of recursive call on x and return successor(y)

This will give us:
add(0, n) = n
add(succ(k), n) = s(add(k, n))

Therefore, for our proof:

We have a term of the following type: ((nat ∧ nat) ⊃ nat). 
This is because we want to add the natural numbers m and n.   
Then, we say that addition on the pair (m, n) implies the existence of another natural number, namely m+n. 

In our proof, a is the pair (m, n), x is the predecesor of m and r is the result of the recursion x+n.
We finally output the successor of r, which equivalently gives x+n+1 = (x+1)+n = m+n. 

}%

rec add : [ ⊢ tm ((nat ∧ nat) ⊃ nat)] = [ ⊢ ⊃I \a. (natE (∧El a) (∧Er a) (\x. \r. (natIr r)))];

%%%% Multiplication %%%%
%{ The definition of multiplication is as follows:

multiply = λ(m : nat). λ(n : nat). rec(m; z; x.y. add(n, y))

where:
- m is the number we recurse over, i.e. add n m times
- n is the number we add m times
- the recusive definition rec(m; z; x.y. add(n, y)), which states:
  - If m = 0, return 0
  - If m = successor of some nat x, y = the recursive result of multiply(x, n), then return add(n, y)

This gives us:
multiply(0, n) = 0
multiply(succ(k), n) = add(n, multiply(k, n))

Therefore, in our proof:

We again have a term of type: ((nat ∧ nat) ⊃ nat). 
This is because we want to multiply the natural numbers m and n.   
Then, the multiplication on the pair (m, n) implies the existence of another natural number, namely m*n. 

In our proof, a is the pair (m, n), x is the predecesor of m, r is the result of the recursion x*n.
As we cannot call add directly, we use its definition inline with a second primitive recursion call to do: n + x*n = n + (m-1)*n = m*n.

}%

rec multiply : [ ⊢ tm ((nat ∧ nat) ⊃ nat) ] = [ ⊢ ⊃I \a. natE (∧El a) natIl (\x. \r. natE r (∧Er a) (\x'. \r'. natIr r'))];

%%%% Subtraction %%%%
%{ The definition of subtraction is as follows:

subtract = λ(m : nat). λ(n : nat) rec(n; m; x.y. pred(x))

where:
- m is the number we subtract from
- n is the number we recurse over, which is the number we subtract
- rec(n; m; x.y. pred(x)) is the recusive definition, which states:
  - If n = 0, return m
  - If n = successor of some nat x, y = the result of recursive call subtract(m, x), then return pred(x) %%% I THINK THIS SHOULD BE Y PROBABLY A TYPO IN THE FORMLUATION

This gives us:
subtract(m, 0) = m
subtract(m, succ(k)) = pred(subtract(m, k)) % CUS IT DOESNT MAKE SENSE TO HAVE PRED(K)

Note that subtracting a number greater than m will result in 0, since pred(0) = 0 and negative numbers do not exist in System T (since we only deal with natural numbers).

Thus, in our proof:

We again have a term of type: ((nat ∧ nat) ⊃ nat) since the subtractaction of n from m implies the natural number m-n exists. 

In our proof, a is the pair (m, n), x is the predecesor of n, r is the result of the recursion m-x.
As we cannot call pred directly, we use its definition inline with a second primitive recursion call to do: (m - x) - 1 = m - (x+1) = m - n.

}%

rec subtract : [ ⊢ tm ((nat ∧ nat) ⊃ nat)] = [ ⊢ ⊃I \a. natE (∧Er a) (∧El a) (\x. \r. natE r natIl (\x'. \r'. x'))];

%%%% Exponentiation %%%%
%{ The definition of exponentiation is as follows:

exp = λ(m : nat). λ(n : nat). rec(n; s(z); x y. multiply(m, y))

where:
- m is the base of the exponentiation
- n is the number we recurse over, which is the exponent
- rec(n; s(z); x y. multiply(m, y)) is the recursive definition which states:
  - If n = 0, return 1 i.e. succ(zero)
  - If n = successor of some nat x, y = the result of the recursion exp(m, x) then return multiply(m, y)

This gives us:
exp(m, 0) = 1
exp(m, succ(k)) = multiply(m, exp(m, k))

Therefore, in our proof:

We again have a term of type: ((nat ∧ nat) ⊃ nat) since exponentiation on natural numbers m and n implies the natural number m^n exists. 

In our proof, a is the pair (m, n), x is the predecesor of n, r is the result of the recursion m-x.
As we cannot call multiply directly, we use its definition inline with a second primitive recursion call 
(which uses a third primitive recursion call for add) to do:
m * (m^k) = m^(k+1) = m^n.

}%

rec exp : [ ⊢ tm ((nat ∧ nat) ⊃ nat) ] = [ ⊢ ⊃I \a. natE (∧Er a) (natIr natIl) (\x. \r. natE (∧El a) natIl (\x'. \r'. natE r x' (\x''. \r''. natIr r'')))];

%%%%%%%%%%%%%%%%%%%%%%%%
%% Weak Normalization %%
%%%%%%%%%%%%%%%%%%%%%%%%

% First, we need to define what it means to be in Normal form in System T, i.e. a fully reduced term
% We add the introduction rules for natural numbers zero and successor since these are final
% We do not add the elimination rule, i.e. the primitive recursion since it is not in Normal form as it still requires a reduction

inductive Normal : [⊢ tm A] → ctype =
  | natNorml : Normal [⊢ natIl]
  | natNormr : Normal [⊢ M] → Normal [⊢ natIr M]
;

% Next, we define how terms compute using Eval, which is our definition of what "reducing to" means
% This is basically our reduction relation and defines how we do the evaluation e → e'
% Then, Eval(M, N) means "term M evaluates to result N"

%{

We need to:

- be done if no more to evaluate i.e. in normal form
- evaluate if natE gets base case
- evaluate if natE gets the step case

}%

inductive Eval : [⊢ tm A] → [⊢ tm A] → ctype = 
  | doneEval : Normal [⊢ M] → Eval [⊢ M] [⊢ M]
  | natEvalBase : Eval [⊢ M] [⊢ natIl] → Eval [⊢ natE M M1 M2] [⊢ M1]     % to match: rec(0; base; step) = base
  | natEvalStep :       % to match: rec(succ N; base; step) = step(N, rec(N; base; step))
;



