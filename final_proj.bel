%% COMP 527 Final Project
%% Beluga mechanization for Gödel's system T 
%% Team 14: Tortoise and the Achilles

%% The goal of this tutorial is to study the extension of ordinary logic with natural numbers and recursion over natural numbers.

%%%%%%%%%%%%%%%
%% Questions %%
%%%%%%%%%%%%%%%

%% is there a way to call add inside add otherwise how would we be able to make this recursive?
%% is there a way to call add inside other proofs i.e. multiply?
%% does our natE for primitive recursion seem reasonable? if not, do you have any advice? thanks!!!!!!

%%%%%%%%%%%%%%%%
%% Objectives %%
%%%%%%%%%%%%%%%%

%% Inherit natural deduction calculus including existence and universal qualifiers
%% Implement the natural numbers (with zero and a successor)
%% Implement primitive recursion in the same way Gödel did  
%% Implement basic arithmetic operations using primitive recursion 

%% IF WE HAVE TIME: weak normalization proof???

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Defining Gödel's System T %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% Defining types and terms in Gödel's System T
i : type. 

LF tp : type =
  | nat : tp        % natural number type

  | ⊃ : tp → tp → tp
  | ⊤ : tp
  | ∧   : tp → tp → tp
  | ∨   : tp → tp → tp
  | ¬  : tp → tp
  | ∀  : (i → tp) → tp    
  | ∃  : (i → tp) → tp     
;

--prefix ¬ 10.
--infix ∧ 6 right.
--infix ∨ 5 right.
--infix ⊃ 4 right.
--prefix ∀ 8.
--prefix ∃ 8.

LF tm : tp → type =

  % natural numbers as a recursive type (with zero and a successor)
  | natIl : tm nat        % zero                                  
  | natIr : tm nat → tm nat  % succ    
  % primitive recursion     
  % should the elim rule start with tm nat or can we leave it as the first? 
  %| natE : tm O -> tm A -> (tm O -> tm C) -> tm A
  % UPDATE: we think this is more accurate actually, but our proofs only type check for the above currently, need to fix
  | natE : tm nat → tm A → (tm nat → tm A → tm A) → tm A

  % natural deduction calculus including existence and universal qualifiers
  | ⊃I : (tm A → tm B) → tm (A ⊃ B)
  | ⊃E : tm (A ⊃ B) → tm A → tm B      
  | ¬I : ({p:tp} tm A → tm p) → tm (¬ A)    
  | ¬E : tm (¬ A) → tm A → tm C      
  | ∧I : tm A → tm B → tm  (A ∧ B)    
  | ∧El : tm (A ∧ B) → tm A
  | ∧Er : tm (A ∧ B) → tm B
  | ∨Il : tm A → tm (A ∨ B)
  | ∨Ir : tm B → tm (A ∨ B)
  | ∨E  : tm (A ∨ B) → (tm A → tm C) → (tm B → tm C) → tm C
  | ⊤I : tm ⊤
  | ∀I : ({a:i} tm (A a)) → tm (∀ (\x. A x))     
  | ∀E : {T:i} tm (∀ A) → tm (A T) 
  | ∃I : {T:i} tm (A T) → tm (∃ A)     
  | ∃E : tm (∃ \x. A x) → ({a:i} tm (A a) → tm C) → tm C
;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Verification of Natural Deduction %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% The following proofs are to verify that we have correctly inherited natural deducition calculus, 
% including existence and universal qualifiers.

rec nd_a : [ ⊢ tm (((A ⊃ B) ∧ (A ∨ C)) ⊃ (B ∨ C)) ] = [ ⊢ ⊃I \u. (∨E (∧Er u) (\a. (∨Il (⊃E (∧El u) a))) (\c. (∨Ir c)))];
rec nd_b : [ ⊢ tm (∀ \x. (∃ \y.  P[x] ⊃ P[y]))] =[ ⊢ ∀I \a. ∃I a (⊃I \u. u)];

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Basic Arithmetic Operations %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%% Predecesor %%%%
%{ The definition of predecesor is as follows:

pred = λ(n : nat). rec(n; z; x.y. x)

where:
- n is the number we recurse over
- rec(n; z; x.y. x) is the recursive definition which states:
  - If n = 0, return 0
  - If n = successor of some number x and y = result of recursive call on x, then return x

This means:
pred(0) = 0     
pred(s(k)) = k

Therefore, in our following proof:

We have a term of the following type: (nat ⊃ nat). 
This is because we want to the predecesor of natural number n, which is also of type natural number.

In our proof, n is our natural number input, x is the predecesor of n and r is the result of the recursion on x.
We output x, which we had already established is the predecesor of n.

}%

rec pred : [ ⊢ tm (nat ⊃ nat)] = [ ⊢ ⊃I \n. natE n natIl (\x. \r. x)];

%%%% Addition %%%%
%{ The definition of addition is as follows: 

add = λ(m : nat). λ(n : nat). rec(m; n; x.y. s(y))

where:
- m is the number we recurse over
- n is the number we add to
- the recursive definition rec(m; n; x.y. s(y)), which states:
  - If m = 0, return n
  - If m = successor of some nat x, let y = result of recursive call on x and return successor(y)

This will give us:
add(0, n) = n
add(s(k), n) = s(add(k, n))

Therefore, for our proof:

We have a term of the following type: ((nat ∧ nat) ⊃ nat). 
This is because we want to add the natural numbers m and n.   
Then, we say that addition on the pair (m, n) implies the existence of another natural number, namely m+n. 

In our proof, a is the pair (m, n), x is the predecesor of m and r is the result of the recursion x+n.
We finally output the successor of r, which equivalently gives x+n+1 = (x+1)+n = m+n. 

}%

rec add : [ ⊢ tm ((nat ∧ nat) ⊃ nat)] = [ ⊢ ⊃I \a. (natE (∧El a) (∧Er a) (\x. \r. (natIr r)))];

%%%% Multiplication %%%%
%{ The definition of multiplication is as follows:

multiply = λ(m : nat). λ(n : nat). rec(m; z; x.y. add(n, y))

where:
- m is the number we recurse over, i.e. add n m times
- n is the number we add m times
- the recusive definition rec(m; z; x.y. add(n, y)), which states:
  - If m = 0, return 0
  - If m = successor of some nat x, y = the recursive result of multiply(x, n), then return add(n, y)

This gives us:
multiply(0, n) = 0
multiply(s(k), n) = add(n, mult(k, n))

}%

rec multiply : [ ⊢ tm ((nat ∧ nat) ⊃ nat)] = [ ⊢ ?];

%%%% Subtraction %%%%
%{ The definition of subtraction is as follows:

subtract = λ(m : nat). λ(n : nat) rec(n; m; x.y. pred(x))

where:
- m is 
- n is 
- rec(n; m; x.y. pred(x)) is the recusive definition, which states:
  - If m = 0, return n
  - If 

}%

%%%% Exponentiation %%%%

% proofs from the paper
