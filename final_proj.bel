%% COMP 527 Final Project
%% Beluga mechanization for Gödel's system T 
%% Team 14: Tortoise and the Achilles

%% The goal of this tutorial is to study the extension of ordinary logic with natural numbers and recursion over natural numbers.

%%%%%%%%%%%%%%%
%% Questions %%
%%%%%%%%%%%%%%%

%% is there a way to call add inside add otherwise how would we be able to make this recursive?
%% is there a way to call add inside other proofs i.e. multiply?
%% does our natE for primitive recursion seem reasonable? if not, do you have any advice? thanks!!!!!!

%%%%%%%%%%%%%%%%
%% Objectives %%
%%%%%%%%%%%%%%%%

%% Inherit natural deduction calculus including existence and universal qualifiers
%% Implement the natural numbers (with zero and a successor)
%% Implement primitive recursion in the same way Gödel did  
%% Implement basic arithmetic operations using primitive recursion 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Defining Gödel's System T %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% Defining types and terms in Gödel's System T
i : type. 

LF tp : type =
  | nat : tp        % natural number type

  | ⊃ : tp → tp → tp
  | ⊤ : tp
  | ∧   : tp → tp → tp
  | ∨   : tp → tp → tp
  | ¬  : tp → tp
  | ∀  : (i → tp) → tp    
  | ∃  : (i → tp) → tp     
;

--prefix ¬ 10.
--infix ∧ 6 right.
--infix ∨ 5 right.
--infix ⊃ 4 right.
--prefix ∀ 8.
--prefix ∃ 8.

LF tm : tp → type =

  % natural numbers as a recursive type (with zero and a successor)
  | natIl : tm nat        % zero                                  
  | natIr : tm nat → tm nat  % succ    
  % primitive recursion     
  % should the elim rule start with tm nat or can we leave it as the first? 
  %| natE : tm O -> tm A -> (tm O -> tm C) -> tm A
  % UPDATE: we think this is more accurate actually, but our proofs only type check for the above currently, need to fix
  | natE : tm nat → tm A → (tm nat → tm A → tm A) → tm A

  % natural deduction calculus including existence and universal qualifiers
  | ⊃I : (tm A → tm B) → tm (A ⊃ B)
  | ⊃E : tm (A ⊃ B) → tm A → tm B      
  | ¬I : ({p:tp} tm A → tm p) → tm (¬ A)    
  | ¬E : tm (¬ A) → tm A → tm C      
  | ∧I : tm A → tm B → tm  (A ∧ B)    
  | ∧El : tm (A ∧ B) → tm A
  | ∧Er : tm (A ∧ B) → tm B
  | ∨Il : tm A → tm (A ∨ B)
  | ∨Ir : tm B → tm (A ∨ B)
  | ∨E  : tm (A ∨ B) → (tm A → tm C) → (tm B → tm C) → tm C
  | ⊤I : tm ⊤
  | ∀I : ({a:i} tm (A a)) → tm (∀ (\x. A x))     
  | ∀E : {T:i} tm (∀ A) → tm (A T) 
  | ∃I : {T:i} tm (A T) → tm (∃ A)     
  | ∃E : tm (∃ \x. A x) → ({a:i} tm (A a) → tm C) → tm C
;

% Defining addition via primitive recursion:

 rec infinity : [ ⊢ tm (nat ⊃ nat)] = [ ⊢ ⊃I \u. (natE u u natIr)];

 rec add : [ ⊢ tm ((nat ∧ nat) ⊃ nat)] = [ ⊢ ⊃I \a. (natE (∧El a) (∧Er a) (\d. (∧I d (∧Er a))))];

% rec multiply : [ ⊢ tm ((nat ∧ nat) ⊃ nat)] = [ ⊢ ?];

% pred, subtract

% proofs from the paper

rec qa : [ ⊢ tm (((A ⊃ B) ∧ (A ∨ C)) ⊃ (B ∨ C)) ] = [ ⊢ ⊃I \u. (∨E (∧Er u) (\a. (∨Il (⊃E (∧El u) a))) (\c. (∨Ir c)))];

rec add : [ ⊢ tm ((nat ∧ nat) ⊃ nat) ] =
  [ ⊢ ⊃I \u. 
      natE (∧El u) 
           (∧Er u) 
           (\v. \r. natIr r)
  ];

